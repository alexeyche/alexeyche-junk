Python 2.7.11+ (default, Apr 17 2016, 14:00:29) 
[GCC 5.3.1 20160413] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> 
import scipy.sparse as sp
import numpy as np
from matplotlib import pyplot as plt


def rep_constant(shape, value):
    r = np.empty(shape)
    r.fill(value)
    return r

v_size = 100
h_size = 0
pop_size = v_size + h_size

# np.random.seed(25)

T = 1000
dt = 1.0
dt_sec = dt/100.0
Tsize = int(T/dt)


factor = 2.0

W = - factor +  2.0 * factor*np.random.rand(pop_size, pop_size)


spikes = sp.lil_matrix((Tsize, pop_size), dtype=np.float32)
t_rate = 2.0
for tt in xrange(Tsize):
    for ni in xrange(v_size):
        if np.random.random() <= t_rate/Tsize:        
            spikes[tt, ni] = 1.0
# for i in xrange(10):
#     spikes[i,i] = 1.0



u_rest = -5.0
beta = 0.75
tau_decay = 10.0
tau_rise = 2.0
tau_refr = 5.0
tau_look_around = 5*tau_decay
lrate = 1e-02
epochs = 1

act = lambda u: 1.0/(1.0 + np.exp(-beta * u))
epsp = lambda x: (1.0/(tau_decay - tau_rise)) * (np.exp(-x/tau_decay) - np.exp(-x/tau_rise))
post_spike_kernel = lambda x: -100.0 * np.exp(-x/tau_refr)
act_factor = lambda _: beta

p_stat = np.zeros((Tsize, pop_size))
u_stat = np.zeros((Tsize, pop_size))
ll_stat = np.zeros((Tsize, pop_size))
W_stat = np.zeros((epochs, pop_size, pop_size))


for ep in xrange(epochs):
    for ti, t in enumerate(np.linspace(0, T, Tsize)):
        if ti % 100 == 0:
            print "epoch {}, T: {}".format(ep, t)
        
        past_idx = max(0, int(ti-dt*tau_look_around))

        spikes_past = spikes[past_idx:ti, :].todense()

        u = rep_constant((pop_size,), u_rest)

        spike_times, neuron_ids = np.where(spikes_past)
        
        for t_sp, n_id in zip(spike_times, neuron_ids):
            t_sp += t - spikes_past.shape[0]*dt
            u += W[n_id, :] * epsp(t - t_sp)
            
            u[n_id] += post_spike_kernel(t - t_sp)

        p = act(u)

        curr_spikes = p > np.random.rand(p.shape[0])
        
        for n_id in np.where(curr_spikes == 1.0)[0]:
            if n_id < v_size:
                continue
            spikes[ti, n_id] = 1.0

        x = np.squeeze(np.array(spikes[ti, :].todense()))
        
        for t_sp, n_id in zip(spike_times, neuron_ids):
            t_sp += t - spikes_past.shape[0]*dt
            W[n_id, :] += lrate * act_factor(u) * (x - p) * epsp(t - t_sp)
            
        u_stat[ti, :] = u
        p_stat[ti, :] = p
        ll_stat[ti, :] = x * np.log(p) + (1.0 - x) * np.log(1.0 - p)

    print "Epoch {} finished, likelihood: {}".format(ep, np.mean(ll_stat))
    W_stat[ep, :, :] = W    

plt.figure(1)
# plt.plot(p_stat[:,v_size + 0])
# plt.figure(2)
plt.imshow(spikes.todense().T, cmap='gray')
plt.show()


epoch 0, T: 0.0
epoch 0, T: 100.1001001
epoch 0, T: 200.2002002
epoch 0, T: 300.3003003
epoch 0, T: 400.4004004
epoch 0, T: 500.500500501
epoch 0, T: 600.600600601
epoch 0, T: 700.700700701
epoch 0, T: 800.800800801
epoch 0, T: 900.900900901
Epoch 0 finished, likelihood: -0.032493106003
>>> spike_times
array([ 3, 35, 39])
>>> neuron_ids
array([71, 61, 42])
>>> t_sp = spike_times[0]