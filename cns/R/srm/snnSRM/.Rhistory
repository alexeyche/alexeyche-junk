dir
source('~/my/git/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
runif(1)
runif(1)*10
runif(1)*50
runif(1)*60
runif(1)*60
40+runif(1)*20
40+runif(1)*20
40+runif(1)*20
40+runif(1)*20
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
class_tf(list(c(1,2),c(1),c(1,2,3,4), NULL), 1, 0, 5)
class_tf(list(c(1,2),c(1),c(1,2,3,4), NULL), 1, 0, 5)(1)
nspikes = list(c(1,2),c(1),c(1,2,3,4)
nspikes = list(c(1,2),c(1),c(1,2,3,4))
nspikes = list(c(1,2),c(1),c(1,2,3,4), NULL)
nspikes = list(c(1,2),c(1),c(1,2,3,4), NULL, c(1))
class_tf(nspikes, 1, 0 ,5)(1)
length(nspikes[[1]])
length(nspikes[[1]])-3
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
class_tf(nspikes, 1, 0 ,5)(1)
class_tf(nspikes, 1, 0 ,5)(2)
class_tf(nspikes, 1, 0 ,5)(3)
class_tf(nspikes, 1, 0 ,5)(4)
class_tf(nspikes, 2, 0 ,5)(4)
class_tf(nspikes, 2, 0 ,5)(2)
nspikes
class_tf(nspikes, 3, 0 ,5)(3)
class_tf(nspikes, 4, 0 ,5)(4)
sort(class_tf(nspikes, 4, 0 ,5)(4))
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
sort(class_tf(nspikes, 4, 0 ,5)(4))
sort(class_tf(nspikes, 4, 0 ,5)(4))
sort(class_tf(nspikes, 4, 0 ,5)(4))
#!/usr/bin/RScript
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
source('include.R')
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
#dir = "/home/alexeyche/prog/sim/R"
dir = "/home/alexeyche/my/sim/R"
system(sprintf("find %s -name \"*.png\" -type f -exec rm -f {} \\;", dir))
M = 50
N = 10
gr1 = TSNeurons(M = M, patterns = list())
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
#file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/my/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
id_m = 1:M
id_n = (M+1):(M+N)
start_w = 5
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
epochs = 50
#run_mode = "run"
run_mode = "learn"
run_options = list(T0 = 0, Tmax = 100, dt = 0.5, learning_rate = 2,
learn_window_size = 50, mode=run_mode, collect_stat=TRUE,
learn_neurons=id_ro,
target_function_gen = class_tf)
patterns = gr1$patterns
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[1]))
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
all_n = M
model_file = sprintf("%s/%dx%d_lr%3.1f_lwz_%3.1f", dir, M, N, run_options$learning_rate, run_options$learn_window_size)
if(run_options$mode == "run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) neurons[[id]]$w = W[,id] ))
} else {
cat("Can't find file for model ", model.file, "\n")
}
}
null_pattern.N = list()
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
net = list()
ep=id_patt=1
net[id_m] = patterns[[id_patt]]$data
net[id_n] = null_pattern.N
run_options$class = patterns[[id_patt]]$class
c(net, neurons, sprob, spot, mean_grad) := run_srm(neurons, net, run_options)
net
W = get_weights_matrix(neurons)
W
if(run_options$mode == "run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) neurons[[id]]$w = W[,id] ))
} else {
cat("Can't find file for model ", model.file, "\n")
}
}
neurons
model_file = sprintf("%s/%dx%d_lr%3.1f_lwz_%3.1f", dir, M, N, run_options$learning_rate, run_options$learn_window_size)
model_file
if(run_options$mode == "run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) neurons[[id]]$w = W[,id] ))
} else {
cat("Can't find file for model ", model.file, "\n")
}
}
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) neurons[[id]]$w = W[,id] ))
} else {
cat("Can't find file for model ", model.file, "\n")
}
neurons
null_pattern.N = list()
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
net = list()
net[id_m] = patterns[[id_patt]]$data
net[id_n] = null_pattern.N
run_options$class = patterns[[id_patt]]$class
attach(run_options, warn.conflicts=FALSE)
neuron_map = sapply(neurons, function(n) n$get_id())
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
if(collect_stat) {
uum = NULL # for stat collecting
ppm = NULL
gr_it = 1
maxw_len = 0
invisible(sapply(learn_neurons_ids, function(n_id) maxw_len<<-max(maxw_len, length(neurons[[n_id]]$w))))
gradients = array(0, dim=c(maxw_len, length(learn_neurons_ids), Tmax %/% learn_window_size))
}
T = seq(T0, Tmax, by=dt)
Tmax=50
T = seq(T0, Tmax, by=dt)
for(t in T) {
uu = sapply(neurons, function(n) n$u(t, net))
pp = g(uu)
fired = pp*dt>runif(N)
idf = neuron_map[fired]
for(id in idf) {
net[[id]] <- c(net[[id]], t)
#cat("t: ", t, " spike of ", id, "\n")
}
}
net
learn_neurons_ids
neurons[learn_neurons_ids]
grad(neurons[learn_neurons_ids], t-learn_window_size, t, net, class, target_function_gen)
neurons = neurons[learn_neurons_ids]
id_n = sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes = lapply(1:length(nspikes), target_function_gen(nspikes, class, T0, Tmax))
left_part = lapply(1:length(id_n), function(number) {
if(!is.null(nspikes[[number]])) {
u = neurons[[number]]$u(nspikes[[number]], net)
#cat("n(", neurons[[number]]$id, ")u=",u,"\n")
(p_stroke(u)/g(u))
}
})
left_part
spike_part = lapply(1:length(id_n), function(id_number) {
sapply(neurons[[id_number]]$id_conn, function(idc) {
if(!is.null(nspikes[[id_number]])) {
sum(left_part[[id_number]]*grab_epsp(nspikes[[id_number]], net[[idc]]))
} else {
0
}
})
})
not_fired = sapply(nspikes, is.null)
#not_fired = rep(FALSE, length(neurons))
int_options = list(T0 = T0, Tmax=Tmax)
sfExport('int_options')
sfExport('net')
sfExport('not_fired')
sfExport('neurons')
int_part = sfLapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
int_part
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
ni = neurons[[1]]
neurons
ni
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
ni
ni = 1
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
ni = 2
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
source('~/my/git/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
attach(run_options, warn.conflicts=FALSE)
neuron_map = sapply(neurons, function(n) n$get_id())
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
if(collect_stat) {
uum = NULL # for stat collecting
ppm = NULL
gr_it = 1
maxw_len = 0
invisible(sapply(learn_neurons_ids, function(n_id) maxw_len<<-max(maxw_len, length(neurons[[n_id]]$w))))
gradients = array(0, dim=c(maxw_len, length(learn_neurons_ids), Tmax %/% learn_window_size))
}
neurons = neurons[learn_neurons_ids]
neurons
id_n = sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes = lapply(1:length(nspikes), target_function_gen(nspikes, class, T0, Tmax))
left_part = lapply(1:length(id_n), function(number) {
if(!is.null(nspikes[[number]])) {
u = neurons[[number]]$u(nspikes[[number]], net)
#cat("n(", neurons[[number]]$id, ")u=",u,"\n")
(p_stroke(u)/g(u))
}
})
spike_part = lapply(1:length(id_n), function(id_number) {
sapply(neurons[[id_number]]$id_conn, function(idc) {
if(!is.null(nspikes[[id_number]])) {
sum(left_part[[id_number]]*grab_epsp(nspikes[[id_number]], net[[idc]]))
} else {
0
}
})
})
spike_part
not_fired = sapply(nspikes, is.null)
int_part = sapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
int_part = lapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
neurons
id_n
id_n = (M+1):(M+N)
id_n
N
source('~/my/git/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
neurons
#!/usr/bin/RScript
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
source('include.R')
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
#dir = "/home/alexeyche/prog/sim/R"
dir = "/home/alexeyche/my/sim/R"
system(sprintf("find %s -name \"*.png\" -type f -exec rm -f {} \\;", dir))
M = 50
N = 10
gr1 = TSNeurons(M = M, patterns = list())
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
#file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/my/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
id_m = 1:M
id_n = (M+1):(M+N)
start_w = 5
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
epochs = 50
#run_mode = "run"
run_mode = "learn"
run_options = list(T0 = 0, Tmax = 100, dt = 0.5, learning_rate = 2,
learn_window_size = 50, mode=run_mode, collect_stat=TRUE,
learn_neurons=id_ro,
target_function_gen = class_tf)
patterns = gr1$patterns
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[1]))
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
all_n = M
model_file = sprintf("%s/%dx%d_lr%3.1f_lwz_%3.1f", dir, M, N, run_options$learning_rate, run_options$learn_window_size)
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) {
neurons[[id]]$w = W[1:length(neurons[[id]]$id_conn),id]
}
))
} else {
cat("Can't find file for model ", model.file, "\n")
}
null_pattern.N = list()
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
net = list()
neurons
ep=id_patt=1
net[id_m] = patterns[[id_patt]]$data
net[id_n] = null_pattern.N
run_options$class = patterns[[id_patt]]$class
attach(run_options, warn.conflicts=FALSE)
neuron_map = sapply(neurons, function(n) n$get_id())
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
if(collect_stat) {
uum = NULL # for stat collecting
ppm = NULL
gr_it = 1
maxw_len = 0
invisible(sapply(learn_neurons_ids, function(n_id) maxw_len<<-max(maxw_len, length(neurons[[n_id]]$w))))
gradients = array(0, dim=c(maxw_len, length(learn_neurons_ids), Tmax %/% learn_window_size))
}
Tmax=50
T = seq(T0, Tmax, by=dt)
for(t in T) {
uu = sapply(neurons, function(n) n$u(t, net))
pp = g(uu)
fired = pp*dt>runif(N)
idf = neuron_map[fired]
for(id in idf) {
net[[id]] <- c(net[[id]], t)
#cat("t: ", t, " spike of ", id, "\n")
}
}
net
neurons=neurons[learn_neurons_ids]
id_n = sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes = lapply(1:length(nspikes), target_function_gen(nspikes, class, T0, Tmax))
left_part = lapply(1:length(id_n), function(number) {
if(!is.null(nspikes[[number]])) {
u = neurons[[number]]$u(nspikes[[number]], net)
#cat("n(", neurons[[number]]$id, ")u=",u,"\n")
(p_stroke(u)/g(u))
}
})
spike_part = lapply(1:length(id_n), function(id_number) {
sapply(neurons[[id_number]]$id_conn, function(idc) {
if(!is.null(nspikes[[id_number]])) {
sum(left_part[[id_number]]*grab_epsp(nspikes[[id_number]], net[[idc]]))
} else {
0
}
})
})
spike_part
int_options = list(T0 = T0, Tmax=Tmax)
sfExport('int_options')
sfExport('net')
sfExport('not_fired')
sfExport('neurons')
not_fired = sapply(nspikes, is.null)
#not_fired = rep(FALSE, length(neurons))
int_options = list(T0 = T0, Tmax=Tmax)
sfExport('int_options')
sfExport('net')
sfExport('not_fired')
sfExport('neurons')
int_part = lapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
mapply("+", spike_part, int_part, SIMPLIFY=FALSE)
start_w = 5
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
M = 50
N = 10
gr1 = TSNeurons(M = M, patterns = list())
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
#file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/my/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
id_m = 1:M
id_n = (M+1):(M+N)
start_w = 5
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) {
neurons[[id]]$w = W[1:length(neurons[[id]]$id_conn),id]
}
))
} else {
cat("Can't find file for model ", model.file, "\n")
}
gr = grad(neurons[learn_neurons_ids], t-learn_window_size, t, net, class, target_function_gen)
gr
learn_neurons_ids
invisible(sapply(learn_neurons_ids, function(i) neurons[[i]]$w <- neurons[[i]]$w + learning_rate * gr[[i]] ))
gr
learning_rate
invisible(sapply(learn_neurons_ids, function(i) neurons[[i]]$w <- neurons[[i]]$w + learning_rate * gr[[i]] ))
neurons
invisible(sapply(1:length(learn_neurons_ids), function(i) neurons[[ learn_neurons_ids[i] ]]$w <- neurons[[ learn_neurons_ids[i] ]]$w + learning_rate * gr[[i]] ))
neurons
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
