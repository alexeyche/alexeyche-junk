p2 = levelplot(W, col.regions=colorRampPalette(c("black", "white")))
p3 = levelplot(mean_grad, col.regions=colorRampPalette(c("black", "white")))
if(!not_fired)
print(p1, position=c(0, 0, 0.5, 1), more=TRUE)
print(p2, position=c(0.5, 0, 1, 0.5), more=TRUE)
print(p3, position=c(0.5, 0.5, 1, 1))
dev.off()
if(open_plots)
system(sprintf("eog -w %s 1>/dev/null 2>/dev/null",pic_filename), ignore.stdout=TRUE, ignore.stderr=TRUE, wait=FALSE)
net_all[[id_patt]] = list(data=net, label=patterns[[id_patt]]$class)
}
net_all = list()
for(id_patt in 1:length(patterns)) {
net[id_m] = patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$class = patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
cat("epoch: ", ep, ", pattern # ", id_patt,"\n")
neurons = net_neurons[[1]]
W = get_weights_matrix(net_neurons)
not_fired = all(sapply(net[id_n], function(sp) length(sp) == 1))
pic_filename = sprintf("%s/R/run_ep%s_patt%s_label%s.png", dir, ep, id_patt, patterns[[id_patt]]$label)
png(pic_filename, width=1024, height=480)
if(!not_fired)
p1 = plot_rastl(net[id_n], sprintf("epoch %d, pattern %d, class %d", ep, id_patt, patterns[[id_patt]]$label))
p2 = levelplot(W, col.regions=colorRampPalette(c("black", "white")))
p3 = levelplot(mean_grad, col.regions=colorRampPalette(c("black", "white")))
if(!not_fired)
print(p1, position=c(0, 0, 0.5, 1), more=TRUE)
print(p2, position=c(0.5, 0, 1, 0.5), more=TRUE)
print(p3, position=c(0.5, 0.5, 1, 1))
dev.off()
if(open_plots)
system(sprintf("eog -w %s 1>/dev/null 2>/dev/null",pic_filename), ignore.stdout=TRUE, ignore.stderr=TRUE, wait=FALSE)
net_all[[id_patt]] = list(data=net, label=patterns[[id_patt]]$class)
}
net_all = list()
for(id_patt in 1:length(patterns)) {
net[id_m] = patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$class = patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
cat("epoch: ", ep, ", pattern # ", id_patt,"\n")
neurons = net_neurons[[1]]
W = get_weights_matrix(net_neurons)
not_fired = all(sapply(net[id_n], function(sp) length(sp) == 1))
pic_filename = sprintf("%s/R/run_ep%s_patt%s_label%s.png", dir, ep, id_patt, patterns[[id_patt]]$label)
png(pic_filename, width=1024, height=480)
if(!not_fired)
p1 = plot_rastl(net[id_n], sprintf("epoch %d, pattern %d, class %d", ep, id_patt, patterns[[id_patt]]$label))
p2 = levelplot(W, col.regions=colorRampPalette(c("black", "white")))
p3 = levelplot(mean_grad, col.regions=colorRampPalette(c("black", "white")))
if(!not_fired)
print(p1, position=c(0, 0, 0.5, 1), more=TRUE)
print(p2, position=c(0.5, 0, 1, 0.5), more=TRUE)
print(p3, position=c(0.5, 0.5, 1, 1))
dev.off()
if(open_plots)
system(sprintf("eog -w %s 1>/dev/null 2>/dev/null",pic_filename), ignore.stdout=TRUE, ignore.stderr=TRUE, wait=FALSE)
net_all[[id_patt]] = list(data=net, label=patterns[[id_patt]]$class)
}
net_all = list()
for(id_patt in 1:length(patterns)) {
net[id_m] = patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$class = patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
cat("epoch: ", ep, ", pattern # ", id_patt,"\n")
neurons = net_neurons[[1]]
W = get_weights_matrix(net_neurons)
not_fired = all(sapply(net[id_n], function(sp) length(sp) == 1))
pic_filename = sprintf("%s/R/run_ep%s_patt%s_label%s.png", dir, ep, id_patt, patterns[[id_patt]]$label)
png(pic_filename, width=1024, height=480)
if(!not_fired)
p1 = plot_rastl(net[id_n], sprintf("epoch %d, pattern %d, class %d", ep, id_patt, patterns[[id_patt]]$label))
p2 = levelplot(W, col.regions=colorRampPalette(c("black", "white")))
p3 = levelplot(mean_grad, col.regions=colorRampPalette(c("black", "white")))
if(!not_fired)
print(p1, position=c(0, 0, 0.5, 1), more=TRUE)
print(p2, position=c(0.5, 0, 1, 0.5), more=TRUE)
print(p3, position=c(0.5, 0.5, 1, 1))
dev.off()
if(open_plots)
system(sprintf("eog -w %s 1>/dev/null 2>/dev/null",pic_filename), ignore.stdout=TRUE, ignore.stderr=TRUE, wait=FALSE)
net_all[[id_patt]] = list(data=net, label=patterns[[id_patt]]$class)
}
net_all
net
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
net_neurons
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
net_neurons
sapply(net_neurons$weights, length)
sapply(net_neurons[[1]]$weights, length)
sapply(net_neurons[[1]]$id_conns, length)
net_neurons[[1]]$ids
net
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
net_neurons$id_conns
net_neurons[[1]]$id_conns
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
sapply(net_neurons[[1]]$id_conns, length)
sum(sapply(net_neurons[[1]]$id_conns, length))
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
sum(sapply(net_neurons[[1]]$id_conns, length))
net_neurons[[1]]$ids
net_neurons[[1]]$ids[9]
net_neurons[[1]]$id_conns[9]
net_neurons[[1]]$id_conns[[9]]
length(net_neurons[[1]]$id_conns[[9]])
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
8*13
8*13+13
sapply(net_neurons[[1]]$id_conns, length)
sapply(net_neurons[[1]]$weights, length)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
library(snnSRM)
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
for(id_patt in 1:length(patterns)) {
net[id_m] = patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$class = patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
cat("epoch: ", ep, ", pattern # ", id_patt,"\n")
neurons = net_neurons[[1]]
W = get_weights_matrix(net_neurons)
not_fired = all(sapply(net[id_n], function(sp) length(sp) == 1))
pic_filename = sprintf("%s/R/run_ep%s_patt%s_label%s.png", dir, ep, id_patt, patterns[[id_patt]]$label)
png(pic_filename, width=1024, height=480)
if(!not_fired)
p1 = plot_rastl(net[id_n], sprintf("epoch %d, pattern %d, class %d", ep, id_patt, patterns[[id_patt]]$label))
p2 = levelplot(W, col.regions=colorRampPalette(c("black", "white")))
p3 = levelplot(mean_grad, col.regions=colorRampPalette(c("black", "white")))
if(!not_fired)
print(p1, position=c(0, 0, 0.5, 1), more=TRUE)
print(p2, position=c(0.5, 0, 1, 0.5), more=TRUE)
print(p3, position=c(0.5, 0.5, 1, 1))
dev.off()
if(open_plots)
system(sprintf("eog -w %s 1>/dev/null 2>/dev/null",pic_filename), ignore.stdout=TRUE, ignore.stderr=TRUE, wait=FALSE)
net_all[[id_patt]] = list(data=net, label=patterns[[id_patt]]$class)
}
test_net_all = list()
for(id_patt in 1:length(run_options$test_patterns)) {
net[id_m] = run_options$test_patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$class = run_options$test_patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
test_net_all[[id_patt]] = list(data=net, label=run_options$test_patterns[[id_patt]]$label)
}
run_options$test_function(net_all, test_net_all)
length(net_all)
length(test_net_all)
train_set = net_all
test_set = test_net_all
train_processed = post_process_set(train_set, 1, 0, duration, binKernel, kernSize)
kernSize=10
train_processed = post_process_set(train_set, 1, 0, duration, binKernel, kernSize)
set= train_set
T0=0
Tmax=100
kernel=binKernel
1:(length(set)/trials)
trials=1
1:(length(set)/trials)
id_patt=1
st_i = (id_patt-1)*trials+1
fin_i = st_i + trials -1
st_i
fin_i
data_proc_l = lapply(set[st_i:fin_i], function(n) binKernel(n$data, T0, Tmax, kernSize))
binSize=10
net_data=set
maxl = max(sapply(net_data, length))
breaks = seq(T0, Tmax, by=binSize)
lb = length(breaks)-1
hist_ans = matrix(0, length(net_data), lb)
breaks
hist_ans
i=1
it_sp = sapply(net_data, function(sp) if(length(sp)>=i) sp[i] else -1)
it_sp
maxl
net_all
net_data=set[[1]]$data
maxl = max(sapply(net_data, length))
breaks = seq(T0, Tmax, by=binSize)
lb = length(breaks)-1
hist_ans = matrix(0, length(net_data), lb)
maxl
i=1
it_sp = sapply(net_data, function(sp) if(length(sp)>=i) sp[i] else -1)
it_sp
time_ids = ceiling((it_sp-T0)/binSize)
time_ids
for(j in 1:length(time_ids)) {
if(time_ids[j]>0) {
hist_ans[j,  time_ids[j]] = hist_ans[j,  time_ids[j]] + 1
}
}
time_ids
j
length(time_ids)
hist_ans
for(j in 1:length(time_ids)) {
if(time_ids[j]>0) {
hist_ans[j,  time_ids[j]] = hist_ans[j,  time_ids[j]] + 1
}
}
j
time_ids[5]
hist_ans[j,  time_ids[j]]
hist_ans
it_sp
Tmax=300
kernSize=10
train_processed = post_process_set(train_set, 1, 0, duration, binKernel, kernSize)
test_processed = post_process_set(test_set, 1, 0, duration, binKernel, kernSize)
perf = ucr_test(train_processed, test_processed, eucl_dist_alg)
st_i = (id_patt-1)*trials+1
fin_i = st_i + trials -1
data_proc_l = lapply(set[st_i:fin_i], function(n) binKernel(n$data, T0, Tmax, kernSize))
data_proc = array(0, dim=c(nrow(set[[st_i]]$data), (Tmax-T0)/kernSize, length(data_proc_l)))
data_proc_l
dim(data_proc)
nrow(set[[st_i]]$data)
set[[st_i]]$data
data_proc = array(0, dim=c(length(set[[st_i]]$data), (Tmax-T0)/kernSize, length(data_proc_l)))
dim(data_proc)
post_process_set = function(set, trials, T0, Tmax, kernel, kernSize) {
spikes_proc = list()
for(id_patt in 1:(length(set)/trials)) {
st_i = (id_patt-1)*trials+1
fin_i = st_i + trials -1
data_proc_l = lapply(set[st_i:fin_i], function(n) binKernel(n$data, T0, Tmax, kernSize))
data_proc = array(0, dim=c(length(set[[st_i]]$data), (Tmax-T0)/kernSize, length(data_proc_l)))
for(i in 1:length(data_proc_l)) {
data_proc[,,i] = data_proc_l[[i]]
}
spikes_proc[[id_patt]] = list(data=apply(data_proc, c(1,2), mean), label=set[[st_i]]$label)
}
return(spikes_proc)
}
kernSize=10
train_processed = post_process_set(train_set, 1, 0, duration, binKernel, kernSize)
test_processed = post_process_set(test_set, 1, 0, duration, binKernel, kernSize)
perf = ucr_test(train_processed, test_processed, eucl_dist_alg)
test_processed
train_processed
train_set
source('~/my/git/alexeyche-junk/cns/R/srm/new/main_ucr.R', echo=TRUE)
10/100
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
туе
net
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
dir = '~/my/sim'
#dir = '~/prog/sim'
system(sprintf("find %s/R -name \"*.png\" -type f -exec rm -f {} \\;", dir))
source('util.R')
source('plot_funcs.R')
source('ucr_ts.R')
source('gen_spikes.R')
source('neuron.R')
source('target_functions.R')
source('learn_and_run_net.R')
source('srm.R')
source('grad_funcs.R')
source('serialize_to_bin.R')
source('eval_funcs.R')
ID_MAX=0
#require(snowfall)
#if(!sfIsRunning()) {
#  sfInit(parallel=TRUE, cpus=10)
#  res = sfClusterEval(require('snnSRM'))
#}
#sfExport('constants')
data = synth # synthetic control
if(!exists('train_dataset')) {
c(train_dataset, test_dataset) := read_ts_file(data)
}
#train_dataset = train_dataset[c(1,101, 2, 102, 3, 103, 4, 104, 5, 105)] # cut
#test_dataset = test_dataset[c(1,101, 2, 102, 3, 103, 4, 104, 5, 105)]
duration = 300
N = 10
start_w = 2.0
M = 50
dt = 0.5
start_w.M = 8.5 #matrix(rnorm( M*N, mean=2, sd=0.5), ncol=N, nrow=M)
start_w.N = 4.25 #matrix(rnorm( (N-1)*N, mean=2, sd=0.5), ncol=N, nrow=(N-1))
gr1 = TSNeurons(M = M)
gr2 = TSNeurons(M = M, ids_c = 100:(100+M))
neurons = SRMLayer(N, start_w.N, p_edge_prob=0.7)
gr1$loadPatterns(train_dataset, duration, dt, lambda=5)
gr2$loadPatterns(test_dataset, duration, dt, lambda=5)
patt_len = length(gr1$patterns)
gr1$patterns = gr1$patterns[sample(patt_len)]
#plot_rastl(gr1$patterns[[3]]$data)
connection = matrix(gr1$ids, nrow=length(gr1$ids), ncol=N)
connect_window = N*2
step = M/N
overlap = 1
for(ni in 0:(N-1)) {
if(ni != 0) connection[1:((ni*step)-overlap),ni+1] = 0
if(ni != N-1) connection[((ni*step)+step+1+overlap):M,ni+1] = 0
}
neurons$connectFF(connection, start_w.M, 1:N )
runmode="learn"
#runmode="run"
run_options = list(T0 = 0, Tmax = duration, dt = dt, learning_rate = 0.05, epochs = 25, weight_decay = 0,
learn_window_size = 150, mode=runmode, collect_stat=TRUE,
target_set = list(target_function_gen = random_4spikes_tf, depress_null=FALSE),
learn_layer_id = 1
#                    test_patterns = gr2$patterns,
#                    test_function = function(train_set, test_set) {
#                      kernSize=10
#                      train_processed = post_process_set(train_set, 1, 0, duration, binKernel, kernSize)
#                      test_processed = post_process_set(test_set, 1, 0, duration, binKernel, kernSize)
#                      perf = ucr_test(train_processed, test_processed, eucl_dist_alg)
#                    }
)
ro = run_options # for debug
id_patt = 1
#model_file = sprintf("%s/R/%s_%dx%d_lr%3.1f_lws_%3.1f", dir, data, M, N, run_options$learning_rate, run_options$learn_window_size)
model_file = sprintf("%s/R/%s_%dx%d", dir, data, M, N)
if(runmode=="run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:(N), function(id) {
neurons$weights[[id]] = W[1:length(neurons$id_conns[[id]]),id]
}
))
} else {
cat("Can't find file for model ", model_file, "\n")
}
}
patterns = gr1$patterns
layers = list(gr1, neurons)
input_neurons = layers[[1]]
net_neurons = layers[2:length(layers)]
patterns = input_neurons$patterns
lengths = sapply(patterns, function(p) length(p$data))
stopifnot(all(lengths == lengths[1]))
id_m = input_neurons$ids
id_n = c(sapply(layers[2:length(layers)], function(n) n$ids))
net = list()
net[id_m] = patterns[[1]]$data
net[id_n] = -Inf
run_options$target_set$class = patterns[[id_patt]]$class
net[id_m] = patterns[[id_patt]]$data
net[id_n] = -Inf
run_options$target_set$label = patterns[[id_patt]]$label
c(net, net_neurons, stat, mean_grad) := run_srm(net_neurons, net, run_options)
binKernel(net, 0, 300, 10)
binKernel(net, 0, 300, 5)
binKernel(net, 0, 300, 7.5)
binKernel(net, 0, 300, 7.1)
binSize=7.1
net_data=net
T0=0
Tmax=300
maxl = max(sapply(net_data, length))
breaks = seq(T0, Tmax, by=binSize)
lb = length(breaks)-1
hist_ans = matrix(0, length(net_data), lb)
breaks
i=1
it_sp = sapply(net_data, function(sp) if(length(sp)>=i) sp[i] else -1)
it_sp
time_ids = ceiling((it_sp-T0)/binSize)
time_ids
300/7.5
300/7
lb
for(j in 1:length(time_ids)) {
if(time_ids[j]>0) {
hist_ans[j,  time_ids[j]] = hist_ans[j,  time_ids[j]] + 1
}
}
i=2
it_sp = sapply(net_data, function(sp) if(length(sp)>=i) sp[i] else -1)
it_sp
time_ids = ceiling((it_sp-T0)/binSize)
time_ids
300/7
300 %% 7
300 % 7
300 / 7
?"%%"
300 %/% 7
lb
breaks
Tmax/T0 > Tmax %/% T0
Tmax
%0
(Tmax-T0)/binSize > (Tmax-T0)/binSize)
((Tmax-T0)/binSize > (Tmax-T0)/binSize)
binSize
binSize=7.5
((Tmax-T0)/binSize > (Tmax-T0)/binSize)
(Tmax-T0)/binSize > (Tmax-T0)%/%binSize
binSize=7.1
(Tmax-T0)/binSize > (Tmax-T0)%/%binSize
binKernel <- function(net_data, T0, Tmax, binSize=10) {
maxl = max(sapply(net_data, length))
breaks = seq(T0, Tmax, by=binSize)
lb = length(breaks)-1
if( (Tmax-T0)/binSize > (Tmax-T0)%/%binSize) lb = lb + 1
hist_ans = matrix(0, length(net_data), lb)
for(i in 1:maxl) {
it_sp = sapply(net_data, function(sp) if(length(sp)>=i) sp[i] else -1)
time_ids = ceiling((it_sp-T0)/binSize)
for(j in 1:length(time_ids)) {
if(time_ids[j]>0) {
hist_ans[j,  time_ids[j]] = hist_ans[j,  time_ids[j]] + 1
}
}
}
return(hist_ans)
}
binKernel(net, 0, 300, 7.1)
binKernel(net, 0, 300, 7.5)
binKernel(net, 0, 300, 100)
binKernel(net, 0, 300, 2)
gr1 = TSNeurons(M = M)
gr2 = TSNeurons(M = M, ids_c = 100:(100+M))
neurons = SRMLayer(N, start_w.N, p_edge_prob=0.5)
gr1$loadPatterns(train_dataset, duration, dt, lambda=5)
gr2$loadPatterns(test_dataset, duration, dt, lambda=5)
patt_len = length(gr1$patterns)
gr1$patterns = gr1$patterns[sample(patt_len)]
#plot_rastl(gr1$patterns[[3]]$data)
connection = matrix(gr1$ids, nrow=length(gr1$ids), ncol=N)
connect_window = N*2
step = M/N
overlap = 4
for(ni in 0:(N-1)) {
if(ni != 0) connection[1:((ni*step)-overlap),ni+1] = 0
if(ni != N-1) connection[((ni*step)+step+1+overlap):M,ni+1] = 0
}
connection
library(snnSRM)
source('~/my/git/alexeyche-junk/cns/R/srm/new/layers.R', echo=TRUE)
library(snnSRM)
neurons
neurons$ids
library(snnSRM)
library(snnSRM)
library(snnSRM)
neurons$ids
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
library(snnSRM)
