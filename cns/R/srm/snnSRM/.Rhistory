if(left<=right) sp[left:right]
})
nspieks
nspikes
nspikes = lapply(nspikes, function(sp) { if((length(sp)==1)&&(sp != c(-Inf))) { mean(sp) } else { NULL } })
nspikes
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes = lapply(nspikes, function(sp) { if((length(sp)==1)||(sp != c(-Inf))) { mean(sp) } else { NULL } })
nspikes
left_part = lapply(1:length(id_n), function(number) {
if(!is.null(nspikes[[number]])) {
u = neurons[[number]]$u(nspikes[[number]], net)
#cat("n(", neurons[[number]]$id, ")u=",u,"\n")
(p_stroke(u)/g(u))
}
})
left_part
number=1
u = neurons[[number]]$u(nspikes[[number]], net)
u
(p_stroke(u)/g(u))
g(u)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
#if(first_spike)
#  nspikes = lapply(nspikes, function(sp) { v=sp[1]; v[!is.na(v)] } )
nspikes = lapply(nspikes, function(sp) { sp[1] })
nspikes
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
#if(first_spike)
#  nspikes = lapply(nspikes, function(sp) { v=sp[1]; v[!is.na(v)] } )
nspikes = lapply(nspikes, function(sp) { sp[length(sp)] })
nspikes
left_part = lapply(1:length(id_n), function(number) {
if(!is.null(nspikes[[number]])) {
u = neurons[[number]]$u(nspikes[[number]], net)
#cat("n(", neurons[[number]]$id, ")u=",u,"\n")
(p_stroke(u)/g(u))
}
})
left_part
spike_part = sapply(1:length(id_n), function(id_number) {
sapply(neurons[[id_number]]$id_conn, function(idc) {
if(!is.null(nspikes[[id_number]])) {
sum(left_part[[id_number]]*grab_epsp(nspikes[[id_number]], net[[idc]]))
} else {
0
}
})
})
spikes_part
spike_part
id_patt
not_fired = sapply(nspikes, is.null)
#not_fired = rep(FALSE, length(neurons))
int_options = list(T0 = T0, Tmax=Tmax)
sfExport('int_options')
sfExport('net')
sfExport('not_fired')
sfExport('neurons')
int_part = sfSapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neurons[[ni]]$id, neurons[[ni]]$id_conn, neurons[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
Nro <- length(patterns)
#!/usr/bin/RScript
setwd("~/prog/alexeyche-junk/cns/R/srm/new")
require(snnSRM)
require(snowfall)
source('util.R')
source('neuron.R')
source('gen_spikes.R')
source('plot_funcs.R')
source('grad_funcs.R')
source('llh.R')
source('srm.R')
source('serialize_to_bin.R')
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
dir = "/home/alexeyche/prog/sim/R"
system(sprintf("find %s -name \"*.png\" -type f -exec rm -f {} \\;", dir))
M = 50
N = 10
id_m = seq(1, M)
id_n = seq(M+1, M+N)
gr1 = TSNeurons(M = M, patterns = list())
file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100)
gr1$loadPattern(file2, 100)
pattern1 <- spikeMatToSpikeList(gr1$patterns[[1]]$data)
pattern2 <- spikeMatToSpikeList(gr1$patterns[[2]]$data)
patterns = list(pattern1, pattern2)
Nro <- length(patterns)
id_ro = seq(M+N+1, M+N+Nro)
id_ro
assert
file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
source('~/prog/alexeyche-junk/cns/R/srm/new/gen_spikes.R', echo=TRUE)
file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
gr1 = TSNeurons(M = M, patterns = list())
file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
gr1$patterns[[1]]
patterns = gr1$patterns
lengths = sapply(patterns, function(p) p$len)
lengths
all(lengths == lengths[[1]])
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/learn_and_run_net.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[[1]]))
M = lengths[[1]]
N = lengths(neurons)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
lengths = sapply(patterns, function(p) p$len)
lengths
M = lengths[1]
N = lengths(neurons)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
warnings()
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[1]))
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
model_file = sprintf("%s/%dx%d_lr%3.1f_lwz_%3.1f", dir, M, N, run_options$learning_rate, run_options$learn_window_size)
if(run_options$mode == "run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
sapply(1:N, function(id) neurons[[id]]$w = W[,id] )
} else {
cat("Can't find file for model ", model.file, "\n")
}
}
null_pattern.N = list()
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
net = list()
net
W
filled.contour(W)
id_patt
id_patt <- 1
net[id_m] = patterns[[id_patt]]$data
length(id_m)
patterns[[id_patt]]$data
source('~/prog/alexeyche-junk/cns/R/srm/new/gen_spikes.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
neurons_ro = list()
for(i in 1:Nr) {
conn <- id_n
w <- c(rep(start_w, N))
neurons_ro[[i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons_ro = list()
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons_ro[[i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons_set = list(first_layer = neurons, readout_layer = neurons_ro)
layers_size = sapply(neurons_set, function(ns) length(ns))
layers_size
layers_size[1]
layers_size[2]
layers_size[2] + 10
layers_size[2]
id_neurons = list()
i = 1
for(ns in neurons_set) {
N = length(ns)
id_neurons[[i]] = seq(all_n+1, all_n+N)
all_n = all_n + N
i = i+1
}
all_n <- 0
M = lengths[1]
id_m = seq(1, M)
all_n = all_n + M
id_neurons = list()
i = 1
for(ns in neurons_set) {
N = length(ns)
id_neurons[[i]] = seq(all_n+1, all_n+N)
all_n = all_n + N
i = i+1
}
id_neurons
neurons
neurons = lapply(neurons_set, function(ns) ns)
neurons
lenght(neurons)
length(neurons)
unlist(neurons_set)
length(unlist(neurons_set))
unlist(neurons_set)[[1]]
length(unlist(neurons_set))1
id_neurons
M = lengths[1]
id_m = seq(1, M)
all_n = M
id_neurons_net = list()
id_neurons = list()
i = 1
for(ns in neurons_set) {
N = length(ns)
id_neurons_net[[i]] = seq(all_n+1, all_n+N)
id_neurons =[[i]] = seq(all_n+1-M, all_n+N-M)
all_n = all_n + N
i = i+1
}
M = lengths[1]
id_m = seq(1, M)
all_n = M
id_neurons_net = list()
id_neurons = list()
i = 1
for(ns in neurons_set) {
N = length(ns)
id_neurons_net[[i]] = seq(all_n+1, all_n+N)
id_neurons[[i]] = seq(all_n+1-M, all_n+N-M)
all_n = all_n + N
i = i+1
}
id_neurons
id_neurons_net
id_neurons
unlist(id_neurons)
id_n = unlist(id_neurons)
id_n
id_n = unlist(id_neurons_net)
id_n
start_w = 7
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(N+1,N+Nro)
for(i in id_ro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[1]))
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
M = 50
N = 10
gr1 = TSNeurons(M = M, patterns = list())
file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file2 <- "/home/alexeyche/prog/sim/stimuli/sd2.csv"
gr1$loadPattern(file, 100, 1)
gr1$loadPattern(file2, 100, 2)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
id_m = 1:M
id_n = (M+1):(M+N)
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(N+1,N+Nro)
for(i in id_ro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
id_n
id_m
id_ro = seq(M+N+1,M+N+Nro)
id_ro
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
all_n = M
null_pattern.N = list()
for(i in ) {
null_pattern.N[[i]] <- -Inf
}
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
null_pattern.N
l = list()
l$open = 1
l
learn_neurons
learn_neurons <- c(61,62)
neuron_map = sapply(neurons, function(n) n$get_id())
sapply(neuron_map, function(id) if(id in learn_neurons) id)
?attach
find
>find
?find
learn_neurons_ids = NULL
for(i in 1:N) {
if(neurons_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
learn_neurons_ids
neuron_map
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in id_ro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons
id_ro
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons
id_ro
M
N
M = 50
N = 10
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons
1:Nro
id_ro
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons
N
id_n
id_m = 1:M
id_n = (M+1):(M+N)
start_w = 7
neurons = list()
for(i in 1:N) {
conn <- id_m
conn <- c(conn, id_n[id_n != id_n[i]]) # id of srm neurons: no self connections
w <- c(rep(start_w, M), rep(start_w/4, N-1))
neurons[[i]] = neuron(w = w, id_conn = conn, id = id_n[i])
}
Nro = 2
id_ro = seq(M+N+1,M+N+Nro)
for(i in 1:Nro) {
conn <- id_n
w <- c(rep(start_w, N))
neurons[[N+i]] = neuron(w = w, id_conn = conn, id = id_ro[i])
}
neurons
neuron_map = sapply(neurons, function(n) n$get_id())
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
learn_neurons_ids
N
N-2
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/prog/alexeyche-junk/cns/R/srm/new/learn_and_run_net.R', echo=TRUE)
gr1$patterns
patterns = gr1$patterns
lengths = sapply(patterns, function(p) p$len)
stopifnot(all(lengths == lengths[1]))
M = lengths[1]
N = length(neurons)
id_m = seq(1, M)
id_n = seq(M+1, M+N)
all_n = M
id_n
model_file = sprintf("%s/%dx%d_lr%3.1f_lwz_%3.1f", dir, M, N-2, run_options$learning_rate, run_options$learn_window_size)
if(run_options$mode == "run") {
if(file.exists(paste(model_file, ".idx", sep=""))) {
W = loadMatrix(model_file, 1)
invisible(sapply(1:N-2, function(id) neurons[[id]]$w = W[,id] ))
} else {
cat("Can't find file for model ", model.file, "\n")
}
}
null_pattern.N = list()
W = loadMatrix(model_file, 1)
W
invisible(sapply(1:N-2, function(id) neurons[[id]]$w = W[,id] ))
invisible(sapply(1:(N-2), function(id) neurons[[id]]$w = W[,id] ))
null_pattern.N = list()
for(i in 1:N) {
null_pattern.N[[i]] <- -Inf
}
net = list()
ep = 1
id_patt =1
net[id_m] = patterns[[id_patt]]$data
net[id_n] = null_pattern.N
run_options$class = patterns[[id_patt]]$class
run_options
attach(run_options, warn.conflicts=FALSE)
neuron_map = sapply(neurons, function(n) n$get_id())
neuron_map
N = length(neurons)
learn_neurons_ids = NULL
for(i in 1:N) {
if(neuron_map[i] %in% learn_neurons) {
learn_neurons_ids = c(learn_neurons_ids, i)
}
}
learn_neurons_ids
if(collect_stat) {
uum = NULL # for stat collecting
ppm = NULL
gr_it = 1
gradients = array(0, dim=c(length(neurons[[1]]$w), N, Tmax %/% learn_window_size))
}
T = seq(T0, Tmax, by=dt)
t = 1
uu = sapply(neurons, function(n) n$u(t, net))
pp = g(uu)
fired = pp*dt>runif(N)
idf = neuron_map[fired]
for(id in idf) {
net[[id]] <- c(net[[id]], t)
#cat("t: ", t, " spike of ", id, "\n")
}
uu
t = 20
uu = sapply(neurons, function(n) n$u(t, net))
pp = g(uu)
fired = pp*dt>runif(N)
idf = neuron_map[fired]
for(id in idf) {
net[[id]] <- c(net[[id]], t)
#cat("t: ", t, " spike of ", id, "\n")
}
uu
id_n = sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes = lapply(1:length(nspikes), target_function_gen(nspikes, class))
nspikes
gr = grad(neurons[learn_neurons_ids], t-learn_window_size, t, net, class, target_function_gen)
gr
source('~/prog/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
net
mean_grad
