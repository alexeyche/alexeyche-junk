!not_fired
int_part
grad = - adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=200)
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=200)
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=300)
Tmax=300
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=300)
int_part = matrix(grad$integral, nrow = length(neurons$id_conns[[1]]), ncol=length(id_n))
filled.contour(int_part)
grad$error
neuronsl = neurons$to_list()
int_part = sapply(1:length(neurons), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neuronsl[[ni]]$id, neuronsl[[ni]]$id_conn, neuronsl[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part
int_part = sapply(1:length(neuronsl), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neuronsl[[ni]]$id, neuronsl[[ni]]$id_conn, neuronsl[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=300)
int_part = matrix(grad$integral, nrow = length(neurons$id_conns[[1]]), ncol=length(id_n))
int_part_gl = sapply(1:length(neuronsl), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neuronsl[[ni]]$id, neuronsl[[ni]]$id_conn, neuronsl[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
int_part_gl
filled.contour(int_part_gl)
filled.contour(-int_part)
Tmax
int_options
int_options$Tmax=300
sfExport('int_options')
sfExport('net')
sfExport('not_fired')
sfExport('neuronsl')
int_part_gl = sfLapply(1:length(neuronsl), function(ni)  {
if(not_fired[ni] == FALSE) {
integrateSRM(constants, int_options, neuronsl[[ni]]$id, neuronsl[[ni]]$id_conn, neuronsl[[ni]]$w, net)
} else {
rep(0, length(neurons[[ni]]$w))
}
})
filled.contour(int_part_gl)
int_part_gl
sapply(int_part_gl, function(x) x)
filled.contour(sapply(int_part_gl, function(x) x))
filled.contour(-int_part)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/gen_spikes.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/main.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/gen_spikes.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
gr1$patterns[[1]]
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
net
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
net
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
neurons[[1]]$id_conns
neurons$id_conns[[1]]
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
gr
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
gr
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/gen_spikes.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/target_functions.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
gr
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
#!/usr/bin/RScript
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
require(snnSRM)
require(snowfall)
source('util.R')
source('neuron.R')
source('gen_spikes.R')
source('plot_funcs.R')
source('grad_funcs.R')
source('llh.R')
source('srm.R')
source('target_functions.R')
ID_MAX=0
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
dir = "/home/alexeyche/prog/sim/R"
M = 50
N = 5
id_m = seq(1, M)
id_n = seq(M+1, M+N)
gr1 = TSNeurons(M = M)
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
gr1$loadPatternFromFile(file, 150, 1, 0.5)
#net <- spikeMatToSpikeList(gr1$patterns[[1]]$data)
net = list()
net[id_m] = gr1$patterns[[1]]$data
start_w = 5.5
neurons = SRMLayer(N, start_w)
neurons$connectFF(gr1$ids, start_w)
null_pattern = list()
for(i in 1:N) {
null_pattern[[i]] <- -Inf
}
pattern = list()
pattern[[1]] <- c(-Inf, 75)
pattern[[2]] <- c(-Inf, 65)
pattern[[3]] <- c(-Inf, 50,80)
pattern[[4]] <- c(-Inf, 100)
pattern[[5]] <- c(-Inf, 10)
epochs = 50
run_options = list(T0 = 0, Tmax = 150, dt = 0.5, learning_rate = 3, learn_window_size = 10, mode="run", collect_stat=FALSE)
net[id_n] <- pattern
id_n = neurons$ids #sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
T0=0
Tmax=150
target_set = run_options$target_set
id_n = neurons$ids #sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
target_set = list(target_function_gen = full_spike_tf, depress_null=TRUE)
id_n = neurons$ids #sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspieks
nspikes
nspikes = lapply(1:length(nspikes), target_set$target_function_gen(nspikes))
nspikes
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
id_n
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
net
id_n = neurons$ids #sapply(neurons, function(n) n$id)
nspikes = lapply(net[id_n], function(sp) {
left = findInterval(T0, sp)+1
right = findInterval(Tmax, sp, rightmost.closed=TRUE)
if(left<=right) sp[left:right]
})
nspikes
id_n
id_n = neurons$ids #sapply(neurons, function(n) n$id)
id_n
neurons
neurons$ids
neurons
neurons[[1]]
neurons = SRMLayer(N, start_w)
neurons
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
net
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
gr
#!/usr/bin/RScript
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
require(snnSRM)
require(snowfall)
source('util.R')
source('neuron.R')
source('gen_spikes.R')
source('plot_funcs.R')
source('grad_funcs.R')
source('llh.R')
source('srm.R')
source('target_functions.R')
ID_MAX=0
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
dir = "/home/alexeyche/prog/sim/R"
M = 50
N = 5
id_m = seq(1, M)
id_n = seq(M+1, M+N)
gr1 = TSNeurons(M = M)
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
gr1$loadPatternFromFile(file, 150, 1, 0.5)
#net <- spikeMatToSpikeList(gr1$patterns[[1]]$data)
net = list()
net[id_m] = gr1$patterns[[1]]$data
start_w = 5.5
neurons = SRMLayer(N, start_w)
neurons$connectFF(gr1$ids, start_w)
null_pattern = list()
for(i in 1:N) {
null_pattern[[i]] <- -Inf
}
pattern = list()
pattern[[1]] <- c(-Inf, 75)
pattern[[2]] <- c(-Inf, 65)
pattern[[3]] <- c(-Inf, 50,80)
pattern[[4]] <- c(-Inf, 100)
pattern[[5]] <- c(-Inf, 10)
epochs = 50
run_options = list(T0 = 0, Tmax = 150, dt = 0.5, learning_rate = 3, learn_window_size = 10, mode="run", collect_stat=FALSE)
layers = list(neurons)
net[id_n] <- pattern
gr = grad_func(layers[[1]], 0, 150, net, list(target_function_gen = full_spike_tf, depress_null=TRUE))
invisible(sapply(1:N, function(i) layers[[1]]$weights[[i]] <- layers[[1]]$weights[[i]] + run_options$learning_rate * gr[[i]] ))
layers[[1]]
#!/usr/bin/RScript
#setwd("~/prog/alexeyche-junk/cns/R/srm/new")
setwd("~/my/git/alexeyche-junk/cns/R/srm/new")
require(snnSRM)
require(snowfall)
source('util.R')
source('neuron.R')
source('gen_spikes.R')
source('plot_funcs.R')
source('grad_funcs.R')
source('llh.R')
source('srm.R')
source('target_functions.R')
ID_MAX=0
if(!sfIsRunning()) {
sfInit(parallel=TRUE, cpus=10)
res = sfClusterEval(require('snnSRM'))
}
sfExport('constants')
dir = "/home/alexeyche/prog/sim/R"
M = 50
N = 5
id_m = seq(1, M)
id_n = seq(M+1, M+N)
gr1 = TSNeurons(M = M)
#file <- "/home/alexeyche/prog/sim/stimuli/sd1.csv"
file <- "/home/alexeyche/my/sim/stimuli/sd1.csv"
gr1$loadPatternFromFile(file, 150, 1, 0.5)
#net <- spikeMatToSpikeList(gr1$patterns[[1]]$data)
net = list()
net[id_m] = gr1$patterns[[1]]$data
start_w = 5.5
neurons = SRMLayer(N, start_w)
neurons$connectFF(gr1$ids, start_w)
null_pattern = list()
for(i in 1:N) {
null_pattern[[i]] <- -Inf
}
pattern = list()
pattern[[1]] <- c(-Inf, 75)
pattern[[2]] <- c(-Inf, 65)
pattern[[3]] <- c(-Inf, 50,80)
pattern[[4]] <- c(-Inf, 100)
pattern[[5]] <- c(-Inf, 10)
epochs = 50
run_options = list(T0 = 0, Tmax = 150, dt = 0.5, learning_rate = 0.5, learn_window_size = 10, mode="run", collect_stat=FALSE)
layers = list(neurons)
net[id_n] <- pattern
gr = grad_func(layers[[1]], 0, 150, net, list(target_function_gen = full_spike_tf, depress_null=TRUE))
invisible(sapply(1:N, function(i) layers[[1]]$weights[[i]] <- layers[[1]]$weights[[i]] + run_options$learning_rate * gr[[i]] ))
neurons
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
plot(g(seq(-150, 0)))
g(-150)
exp(alpha*(tr-u)
exp(alpha*(tr-u))
u=-150
exp(alpha*(tr-u))
log(1.0001)
log(1.0001) - alpha(tr-u)
log(1.0001) - alpha*(tr-u)
tr
u
beta*log(1.0001) - alpha*(tr-u)
beta*log(1.0001) - alpha*(tr-u)/alpha
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
g(-150)
g(-150:-30)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
g(-150:-30)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
g(-150:-30)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
g(-150:-30)
exp(alpha*(tr-u)
exp(alpha*(tr-u))
tr
u
log(1.1+exp(alpha*(tr-u))) - exp(alpha*(tr-u))
log(1+exp(alpha*(tr-u))) - exp(alpha*(tr-u))
log(1.5+exp(alpha*(tr-u))) - exp(alpha*(tr-u))
log(10+exp(alpha*(tr-u))) - exp(alpha*(tr-u))
exp(alpha*(tr-u))
log(10)
log(10+exp(alpha*(tr-u)))
log(10+exp(alpha*(tr-u))) - alpha*(tr-u)
log(100+exp(alpha*(tr-u))) - alpha*(tr-u)
log(100+exp(alpha*(tr-u)))
log(1+exp(alpha*(tr-u)))
log(1+exp(alpha*(tr-u)))
log(1+exp(alpha*(tr-u)))
tr
u
alpha*(tr-u)
tr-u
tr
u
log(1.1+exp(alpha*(tr-u)))
alpha*(tr-u)
log(1+exp(alpha*(tr-u)))
log(10+exp(alpha*(tr-u)))
log(100+exp(alpha*(tr-u)))
log(100)
exp(alpha*(tr-u))
exp(100)
e
log(2.688117e+43)
p_stroke(u)/g(u)
u=seq(-150,0); p_stroke(u)/g(u)
u=seq(-150,50); p_stroke(u)/g(u)
u=seq(-150,50); g(u)
u=seq(-150,50); p_stroke(u)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); p_stroke(u)
u=seq(-150,50); g(u)
u=seq(-150,50); p_stroke(u)/g(u)
u=seq(-150,50); g(u)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); g(u)
u=seq(-150,50); p_stroke(u)/g(u)
u=seq(-150,50); plot(p_stroke(u)/g(u))
u=seq(-150,50); plot(p_stroke(u)/g(u), u)
u=seq(-150,50); plot(u,p_stroke(u)/g(u))
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); plot(u,p_stroke(u)/g(u))
u=seq(-150,50); g(u)
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); plot(u,p_stroke(u)/g(u))
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); plot(u,p_stroke(u)/g(u))
source('~/my/git/alexeyche-junk/cns/R/srm/new/srm_funcs.R', echo=TRUE)
u=seq(-150,50); plot(u,p_stroke(u)/g(u))
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
neurons
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
(p_stroke(u)/g(u))
u=seq(-150,0)
(p_stroke(u)/g(u))
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
warnings()
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
c(net, layers, stat) := run_srm(layers, net, run_options)
p1 = plot_rastl(net[id_n], sprintf("epoch %d", ep))
net[id_n] <- pattern
net[id_n] <- null_pattern
c(net, layers, stat) := run_srm(layers, net, run_options)
if(!not_fired)
p1 = plot_rastl(net[id_n], sprintf("epoch %d", ep))
net
p1 = plot_rastl(net[id_n], sprintf("epoch %d", ep))
id_n
net
plot_rastl(net[id_n], sprintf("epoch %d", ep))
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/llh.R', echo=TRUE)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
neurons$id_conns
c(neurons$id_conns)
sapply(neurons$id_conns, function(x) x)
?uniq
unique(sapply(neurons$id_conns, function(x) x))
unique(c(sapply(neurons$id_conns, function(x) x)))
syn_epsp = sapply(net[net_to_calc], function(sp) sum(epsp(t-sp)))
net_to_calc = unique(c(sapply(neurons$id_conns, function(x) x)))
syn_epsp = sapply(net[net_to_calc], function(sp) sum(epsp(t-sp)))
t=1
syn_epsp = sapply(net[net_to_calc], function(sp) sum(epsp(t-sp)))
syn_epsp
syn_epsp = sapply(net, function(sp) sum(epsp(t-sp)))
syn_epsp
syn_epsp[neurons$id_conns[[1]]]
u = p_stroke(neurons$u(t, net))
uu
u
syn_epsp[neurons$id_conns[[id]] ]
id=1
syn_epsp[neurons$id_conns[[id]] ]
syn_epsp
sapply(1:neurons$len, function(id) syn_epsp[neurons$id_conns[[id]] ] * ps[id] )
ps = p_stroke(neurons$u(t, net))
sapply(1:neurons$len, function(id) syn_epsp[neurons$id_conns[[id]] ] * ps[id] )
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)
T0=0
Tmax=150
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)
grad
int_part = list()
iter=0
for(id in 1:neurons$len) {
int_part[[id]] = grad[(iter+1):length(neurons$id_conns[[id]])]
iter = iter + length(neurons$id_conns[[id]])
}
int_part
grad
length(neurons$id_conns[[id]])
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)
int_part = list()
iter=0
for(id in 1:neurons$len) {
int_part[[id]] = grad[(iter+1):length(neurons$id_conns[[id]])]
iter = iter + length(neurons$id_conns[[id]])
}
int_part
1:neurons$len
grad[(iter+1):length(neurons$id_conns[[id]])]
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)$integral
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)$integral
int_part = list()
iter=0
for(id in 1:neurons$len) {
int_part[[id]] = -grad[(iter+1):length(neurons$id_conns[[id]])]
iter = iter + length(neurons$id_conns[[id]])
}
int_part
dim(grad)
length(dim)
length(grad)
54*5
int_part = list()
iter=0
for(id in 1:neurons$len) {
int_part[[id]] = -grad[(iter+1):length(neurons$id_conns[[id]])]
iter = iter + length(neurons$id_conns[[id]])
}
iter
grad = adaptIntegrate(function(t) integrand(t, net, neurons), T0, Tmax, tol=1e-03, fDim=length(id_n)*length(neurons$id_conns[[1]]), maxEval=100)$integral
int_part = list()
iter=1
for(id in 1:neurons$len) {
int_part[[id]] = -grad[iter:(iter+length(neurons$id_conns[[id]]))]
iter = iter + length(neurons$id_conns[[id]]) +1
}
int_part
iter
int_part = list()
iter=1
for(id in 1:neurons$len) {
int_part[[id]] = -grad[iter:(iter+length(neurons$id_conns[[id]]))]
iter = iter + length(neurons$id_conns[[id]])
}
int_part
int_part = list()
iter=1
for(id in 1:neurons$len) {
int_part[[id]] = -grad[iter:(iter+length(neurons$id_conns[[id]])-1)]
iter = iter + length(neurons$id_conns[[id]])
}
int_part
sapply(int_part, length)
source('~/my/git/alexeyche-junk/cns/R/srm/new/test_llh.R', echo=TRUE)
prod(cos(c(50, 50)))
