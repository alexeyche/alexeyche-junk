{-# OPTIONS_HADDOCK prune, ignore-exports #-}

{------------------------------------------------------------------------------}
{- | Реализация алгоритма Дойча на языке Haskell.

   Автор:     Душкин Р. В.
   Проект:    Квантовые вычисления и функциональное программирование
                                                                              -}
{------------------------------------------------------------------------------}

module Deutsch
(
  -- * Классическая реализация алгоритма
  deutsch,
  testDeutsch,
  
  -- * Квантовая реализация алгоритма
  deutsch',
  testDeutsch'
)
where

{-[ СЕКЦИЯ ИМПОРТА ]-----------------------------------------------------------}

import Data.Complex
import Data.List (transpose)

{-[ СИНОНИМЫ ТИПОВ ]-----------------------------------------------------------}

-- | Синоним типа для представления вектора. Просто список. При использовании
--   разработчик должен самостоятельно следить 
type Vector a = [a]

-- | Синоним типа для представления матрицы. Список списков. Опять же, при
--   использовании этого типа разработчик всегда сам должен следить как за
--   размерностью списка списков, так и за размерностями каждого из списков
--   (предполагается, что они должны быть одинаковыми).
type Matrix a = [Vector a]

{-[ ФУНКЦИИ ]------------------------------------------------------------------}

-- | Первая функция (0) для проверки при помощи алгоритма Дойча в классическом
--   исполнении.
f1 :: Integer -> Integer
f1 _ = 0

-- | Вторая функция (1) для проверки при помощи алгоритма Дойча в классическом
--   исполнении.
f2 :: Integer -> Integer
f2 _ = 1

-- | Третья функция (id) для проверки при помощи алгоритма Дойча в классическом
--   исполнении.
f3 :: Integer -> Integer
f3 = id

-- | Четвёртая функция (not) для проверки при помощи алгоритма Дойча в
--   классическом исполнении.
f4 :: Integer -> Integer
f4 x = (x + 1) `mod` 2

-- | Классическая реализация алгоритма Дойча. Используется два вызова функции,
--   переданной на проверку.
deutsch :: (Integer -> Integer) -> IO ()
deutsch f = putStrLn (if f 0 == f 1
                        then "Функция константна."
                        else "Функция сбалансирована.")

-- | Функция для тестирования классической реализации алгоритма Дойча.
testDeutsch :: IO ()
testDeutsch = mapM_ deutsch [f1, f2, f3, f4]

-- | Сервисная функция для перевода списка счётных чисел в список комплексных
--   чисел. Используется для преобразования кубитов в каноническом представлении
--   с целыми коэффициентами при квантовых состояниях.
vectorToComplex :: Integral a => Vector a -> Vector (Complex Double)
vectorToComplex = map (\i -> fromIntegral i :+ 0.0)

-- | Ещё одна сервисная функция для перевода матрицы счётных чисел в матрицу
--   комплексных чисел. Используется для преобразования унитарных матриц
--   (квантовых операторов) в матричном представлении с целями коэффициентами.
matrixToComplex :: Integral a => Matrix a -> Matrix (Complex Double)
matrixToComplex = map vectorToComplex

-- | Кубит |0>.
qubitZero :: Vector (Complex Double)
qubitZero = vectorToComplex [1, 0]

-- | Кубит |1>.
qubitOne :: Vector (Complex Double)
qubitOne = vectorToComplex [0, 1]

-- | Функция для связывания двух кубитов в одну систему из нескольких кубитов.
--   По сути, производит тензорное умножение кубитов друг на друга.
entangle :: Num a => Vector a -> Vector a -> Vector a
entangle q1 q2 = [qs1 * qs2 | qs1 <- q1, qs2 <- q2]

-- | Константная функция, возвращающая матричное представление квантового гейта
--   X (отрицание).
gateX :: Matrix (Complex Double)
gateX = matrixToComplex [[0, 1],
                         [1, 0]]

-- | Константная функция, возвращающая матричное представление квантового гейта
--   H (преобразование Адамара).
gateH :: Matrix (Complex Double)
gateH = ((1/sqrt 2) :+ 0.0) <*> matrixToComplex [[1,  1],
                                                 [1, -1]]

-- | Функция, вычисляющая произведение матрицы на вектор. В итоге получается
--   вектор. Разработчик должен сам следить за корректностью размерностей
--   матрицы и вектора, подаваемых на вход этой фунции.
apply :: Num a => Matrix a -> Vector a -> Vector a
apply m v = map (sum . zipWith (*) v) m

-- | Специальный синоним для функции `apply`, который меняет порядок аргументов.
--   Этот оператор предназначен для прямой записи последовательности применения
--   гейтов к кубитам.
(|>) :: Num a => Vector a -> Matrix a -> Vector a
(|>) = flip apply

-- | Оператор для умножения матрицы на число. Первым аргументом получает число,
--   а вторым, соответственно, матрицу.
(<*>) :: Num a => a -> Matrix a -> Matrix a
c <*> m = map (map (c *)) m

-- | Оператор для тензорного перемножения матриц.
(<+>) :: Num a => Matrix a -> Matrix a -> Matrix a
m1 <+> m2 = concatMap collateRows $ groups n [c <*> m2 | c <- concat m1]
  where
    n = length $ head m1
    
    groups :: Int -> [a] -> [[a]]
    groups i s | null s = []
               | otherwise  = let (h, t) = splitAt i s
                              in   h : groups i t

    collateRows :: [Matrix a] -> Matrix a
    collateRows = map concat . transpose

-- | Функция, реализующая квантовый алгоритм Дойча, который за один
--   вычислительный шаг осуществляет проверку, является ли заданная функция,
--   выраженная как унитарное преобразование, константной или сбалансированной.
--   Функция должна быть бинарной и от одного аргумента (всего может быть 4
--   вида таких функций).
deutsch' :: Matrix (Complex Double) -> IO ()
deutsch' f = do let (result:_) = measure circuit
                case result of
                  '0' -> putStrLn "Функция f константна."
                  '1' -> putStrLn "Функция f сбалансирована."
                  _   -> return ()
  where
    gateH2  = gateH <+> gateH
    circuit = entangle qubitZero (qubitZero |> gateX) |> gateH2
                                                      |> f
                                                      |> gateH2
    measure q = let result = map (\c -> round (realPart (c * conjugate c))) q
                in  case result of
                      [0, 1, 0, 0] -> "01"
                      [0, 0, 0, 1] -> "11"
                      _            -> "??"

-- | Функция для тестирования квантовой реализации алгоритма Дойча.
testDeutsch' :: IO ()
testDeutsch' = mapM_ deutsch' [f1', f2', f3', f4']

-- | Унитарное преобразование для представления квантового оракула функции
--   \f x = 0\.
f1' :: Matrix (Complex Double)
f1' = matrixToComplex [[1, 0, 0, 0],
                       [0, 1, 0, 0],
                       [0, 0, 1, 0],
                       [0, 0, 0, 1]]

-- | Унитарное преобразование для представления квантового оракула функции
--   \f x = 1\.
f2' :: Matrix (Complex Double)
f2' = matrixToComplex [[0, 1, 0, 0],
                       [1, 0, 0, 0],
                       [0, 0, 0, 1],
                       [0, 0, 1, 0]]

-- | Унитарное преобразование для представления квантового оракула функции
--   \f x = x\.
f3' :: Matrix (Complex Double)
f3' = matrixToComplex [[1, 0, 0, 0],
                       [0, 1, 0, 0],
                       [0, 0, 0, 1],
                       [0, 0, 1, 0]]

-- | Унитарное преобразование для представления квантового оракула функции
--   \f x = not x\.
f4' :: Matrix (Complex Double)
f4' = matrixToComplex [[0, 1, 0, 0],
                       [1, 0, 0, 0],
                       [0, 0, 1, 0],
                       [0, 0, 0, 1]]

{-[ КОНЕЦ МОДУЛЯ ]-------------------------------------------------------------}
